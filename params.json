{"name":"Beaneater","google":"","tagline":"Best way to consume beanstalkd","body":"# Beaneater\r\n\r\n[Beaneater](http://kr.github.com/beanstalkd/) is a simple, fast work queue. Its interface is generic, but was\r\noriginally designed for reducing the latency of page views in high-volume web\r\napplications by running time-consuming tasks asynchronously. \r\nRead the [beanstalk protocol](https://github.com/kr/beanstalkd/blob/master/doc/protocol.md) for more detail.\r\n\r\n## Installation\r\n\r\nInstall beaneater as a gem:\r\n\r\n```\r\ngem install beaneater\r\n```\r\n\r\nor add this to your Gemfile:\r\n\r\n```ruby\r\n# Gemfile\r\ngem 'beaneater'\r\n```\r\n\r\nand run `bundle install` to install the dependency.\r\n\r\n## Usage\r\n\r\n### Connection\r\n\r\nTo interact with a beanstalk queue, first establish a client connection by providing host and port:\r\n\r\n```ruby\r\n@beanstalk = Beaneater::Connection.new(['10.0.1.5:11300'])\r\n```\r\n\r\n### Tubes\r\n\r\nThe system has one or more tubes which contain jobs. Each tube consists of a ready, delay, and buried queue for jobs. \r\nTubes can have jobs inserted (put) in to used tubes and jobs pulled out (reserved) from watched tubes.\r\nYou can fetch a tube reference:\r\n\r\n```ruby\r\n@tube = @beanstalk.tubes.find \"some-tube-here\"\r\n```\r\n\r\nWhen a client connects, its watch list is initially just the tube named `default`.  \r\nTube names are at most 200 bytes. It specifies the tube to use. If the tube does not exist, it will be automatically created.\r\nYou can also see lists of tubes in various states:\r\n\r\n```ruby\r\n# The list-tubes command returns a list of all existing tubes\r\n@beanstalk.tubes.all\r\n\r\n# Returns the tube currently being used by the client (for insertion)\r\n@beanstalk.tubes.used\r\n\r\n# Returns a list tubes currently being watched by the client (for consumption)\r\n@beanstalk.tubes.watched\r\n```\r\n\r\nTo recap: each beanstalkd client manages two separate concerns: which tube newly created jobs are put into, \r\nand which tube(s) jobs are reserved from. Accordingly, there are two separate sets of functions for these concerns:\r\n\r\n  * `use` and `using` affect where put places jobs;\r\n  * `watch` and `watching` control where reserve takes jobs from.\r\n\r\nNote that these concerns are fully orthogonal: for example, when you use a tube, it is not automatically watch-ed. \r\nNeither does watch-ing a tube affect the tube you are using.\r\n\r\n### Jobs\r\n\r\nA job in beanstalk gets created by a client and includes a 'body' which contains all relevant job metadata.\r\nWith beanstalk, a job is enqueued into a tube and then later reserved and processed. \r\nHere is a picture of the typical job lifecycle:\r\n\r\n```\r\n   put            reserve               delete\r\n  -----> [READY] ---------> [RESERVED] --------> *poof*\r\n```\r\n\r\nYou can put a job onto the beanstalk queue using the `put` command on a tube:\r\n\r\n```ruby\r\n@tube.put \"job-data-here\"\r\n```\r\n\r\nYou can also specify additional metadata to control job behavior. In particular,\r\nyou can specify the `priority`, `delay`, and `ttr` of a particular job:\r\n\r\n```ruby\r\n# defaults are priority 0, delay of 0 and ttr of 120 seconds\r\n@tube.put \"job-data-here\", :pri => 1000, :delay => 50, :ttr => 200\r\n```\r\n\r\nThe `priority` argument is an integer < 2**32. Jobs with a smaller priority take precedence over jobs with larger priorities. \r\nThe `delay` argument is an integer number of seconds to wait before putting the job in the ready queue.\r\nThe `ttr` argument is the time to run -- is an integer number of seconds to allow a worker to run this job. \r\n\r\n### Processing Jobs (Manual)\r\n\r\nIn order to process jobs, the worker should first specify the intended tubes to watch. If not specified, \r\nthis will default to watching just the `default` tube.\r\n\r\n```ruby\r\n@beanstalk = Beaneater::Connection.new(['10.0.1.5:11300'])\r\n@beanstalk.tubes.watch!('some-tube-name', 'some-other-tube')\r\n```\r\n\r\nThen you can use the `reserve` method which will return the\r\nfirst available job within the watched tubes:\r\n\r\n```ruby\r\njob = @beanstalk.tubes.reserve\r\n# => <Beaneater::Job id=5 body=\"foo\">\r\nputs job.body\r\n# prints 'job-data-here'\r\nprint job.stats.state # => 'reserved'\r\n```\r\n\r\nBy default, reserve will wait indefinitely for a job, if you want to specify a timeout,\r\nsimply pass the timeout (in seconds):\r\n\r\n\r\n```ruby\r\njob = @beanstalk.tubes.reserve(5) # wait 5 secs\r\n# => <Beaneater::Job id=5 body=\"foo\">\r\n```\r\n\r\nYou can 'release' jobs back onto a queue to retry them later:\r\n\r\n```ruby\r\njob = @beanstalk.tubes.reserve\r\n# ...job has ephemeral fail...\r\njob.release :delay => 5\r\nprint job.stats.state # => 'delayed'\r\n```\r\n\r\nYou can also 'delete' jobs that are completed:\r\n\r\n```ruby\r\njob = @beanstalk.tubes.reserve\r\n# ...process job...\r\njob.delete\r\n```\r\n\r\nBeanstalk jobs can also be buried if they fail, rather than being deleted:\r\n\r\n```ruby\r\njob = @beanstalk.tubes.reserve\r\n# ...job fails...\r\njob.bury\r\nprint job.stats.state # => 'buried'\r\n```\r\nBurying a job means that the job is pulled out of the queue into a special 'holding' area for later inspection or reuse.\r\nTo reanimate a buried job, you can mark buried jobs as ready with 'kick':\r\n\r\n```ruby\r\n@beanstalk.tubes.watch!('some-tube')\r\n@beanstalk.tubes.kick(3)\r\n```\r\n\r\nThis would kick 3 buried jobs for 'some-tube' back to the 'ready' state. Jobs can also be\r\ninspected using the 'peek' commands. To find and peek at a particular job:\r\n\r\n```ruby\r\n@beanstalk.jobs.find(123)\r\n# => <Beaneater::Job id=123 body=\"foo\">\r\n```\r\n\r\nor you can peek at jobs on a tube:\r\n\r\n```ruby\r\n@tube = @beanstalk.tubes.find('foo')\r\n@tube.peek(:ready)\r\n# => <Beaneater::Job id=123 body=\"ready\">\r\n@tube.peek(:buried)\r\n# => <Beaneater::Job id=456 body=\"buried\">\r\n@tube.peek(:delayed)\r\n# => <Beaneater::Job id=789 body=\"delayed\">\r\n```\r\n\r\n### Processing Jobs (Automatic)\r\n\r\nInstead of using `watch` and `reserve`, you can also use the higher level `register` and `process` methods to\r\nprocess jobs. First you can 'register' how to handle jobs from various tubes:\r\n\r\n```ruby\r\n@beanstalk.jobs.register('some-tube-name', :retry_on => [Timeout::Error]) do |job|\r\n  do_something(job)\r\nend\r\n\r\n@beanstalk.jobs.register('some-other-name', :retry_on => [SomeCustomException]) do |job|\r\n  do_something_else(job)\r\nend\r\n```\r\n\r\nOnce you have registered the handlers for known tubes, calling `process!` will begin an 'infinite' \r\nloop processing jobs as defined by the register blocks:\r\n\r\n```ruby\r\n@beanstalk.jobs.process!\r\n```\r\n\r\nProcess runs the following pseudo-code steps:\r\n \r\n 1. watch all registered tubes\r\n 1. reserve the next job\r\n 1. once job is reserved, invoke the registered handler based on the tube name\r\n 1. if no exceptions occur, delete the job (success!)\r\n 1. if 'retry_on' exceptions occur, call 'release' (retry!)\r\n 1. if other exception occurs, call 'bury' (error!)\r\n 1. repeat steps 2-5\r\n\r\nThis is well-suited for a 'worker' job processing process.\r\n\r\n### Stats\r\n\r\nBeanstalk has plenty of commands for introspecting the state of the queues and jobs. These methods include:\r\n\r\n```ruby\r\n# Get overall stats about the job processing that has occurred\r\n@beanstalk.stats\r\n# => { 'current-connections': 1, 'current-jobs-buried': 0, 'current-jobs-delayed': 0, ... }\r\n\r\n# Get statistical information about the specified job if it exists\r\n@beanstalk.job.find(some_job_id).stats\r\n# => {'age': 0, 'id': 2, 'state': 'reserved', 'tube': 'default', ... }\r\n\r\n# Get statistical information about the specified tube if it exists\r\n@beanstalk.tubes.find('some_tube_name').stats\r\n# => { 'some_tube_name': '', 'current-jobs-ready': 0, 'current-jobs-reserved': 0  }\r\n```\r\n\r\nBe sure to check the [beanstalk protocol](https://github.com/kr/beanstalkd/blob/master/doc/protocol.md) for\r\nmore details about the stats commands.\r\n\r\n## Resources\r\n\r\nThere are other resources helpful when learning about beanstalk:\r\n\r\n * [Beanstalkd homepage](http://kr.github.com/beanstalkd/)\r\n * [beanstalk on github](https://github.com/kr/beanstalkd)\r\n * [beanstalk protocol](https://github.com/kr/beanstalkd/blob/master/doc/protocol.md)\r\n\r\n## Contributors\r\n\r\n - [Nico Taing](https://github.com/Nico-Taing) - Creator and co-maintainer\r\n - [Nathan Esquenazi](https://github.com/nesquena) - Contributor and co-maintainer","note":"Don't delete this file! It's used internally to help with page regeneration."}