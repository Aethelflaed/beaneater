{"name":"Beaneater","google":"","tagline":"Best way to consume beanstalkd","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# Beaneater\r\n\r\n[Beaneater](http://kr.github.com/beanstalkd/) is a simple, fast work queue. Its interface is generic, but was\r\noriginally designed for reducing the latency of page views in high-volume web\r\napplications by running time-consuming tasks asynchronously. \r\nRead the [beanstalk protocol](https://github.com/kr/beanstalkd/blob/master/doc/protocol.md) for more detail.\r\n\r\n## Installation\r\n\r\nInstall beaneater as a gem:\r\n\r\n```\r\ngem install beaneater\r\n```\r\n\r\nor add this to your Gemfile:\r\n\r\n```ruby\r\n# Gemfile\r\ngem 'beaneater'\r\n```\r\n\r\nand run `bundle install` to install the dependency.\r\n\r\n## Usage\r\n\r\n### Connection\r\n\r\nTo interact with a beanstalk queue, first establish a connection by providing a set of addresses:\r\n\r\n```ruby\r\n@beanstalk = Beaneater::Pool.new(['10.0.1.5:11300'])\r\n```\r\n\r\nYou can conversely close and dispose of a pool at any time with:\r\n\r\n```ruby\r\n@beanstalk.close\r\n```\r\n\r\n### Tubes\r\n\r\nBeanstalkd has one or more tubes which can contain any number of jobs. \r\nJobs can be inserted (put) into the used tube and pulled out (reserved) from watched tubes. \r\nEach tube consists of a _ready_, _delayed_, and _buried_ queue for jobs. \r\n\r\nWhen a client connects, its watch list is initially just the tube named `default`.  \r\nTube names are at most 200 bytes. It specifies the tube to use. If the tube does not exist, it will be automatically created.\r\n\r\nTo interact with a tube, first `find` the tube:\r\n\r\n```ruby\r\n@tube = @beanstalk.tubes.find \"some-tube-here\"\r\n# => <Tube name='some-tube-here'>\r\n```\r\n\r\nTo reserve jobs from beanstalk, you will need to 'watch' certain tubes:\r\n\r\n```ruby\r\n# Watch only the tubes listed below (!)\r\n@beanstalk.tubes.watch!('some-tube')\r\n# Append tubes to existing set of watched tubes\r\n@beanstalk.tubes.watch('another-tube')\r\n# You can also ignore tubes that have been watched previously\r\n@beanstalk.ignore('some-tube')\r\n```\r\n\r\nYou can easily get a list of all, used or watched tubes:\r\n\r\n```ruby\r\n# The list-tubes command returns a list of all existing tubes\r\n@beanstalk.tubes.all\r\n# => [<Tube name='foo'>, <Tube name='bar'>]\r\n\r\n# Returns the tube currently being used by the client (for insertion)\r\n@beanstalk.tubes.used\r\n# => <Tube name='bar'>\r\n\r\n# Returns a list tubes currently being watched by the client (for consumption)\r\n@beanstalk.tubes.watched\r\n# => [<Tube name='foo'>]\r\n```\r\n\r\nYou can also temporarily 'pause' the execution of a tube by specifying the time:\r\n\r\n```ruby\r\ntube = @beanstalk.tubes[\"some-tube-here\"]\r\ntube.pause(3) # pauses tube for 3 seconds\r\n```\r\n\r\nor even clear the tube of all jobs:\r\n\r\n```ruby\r\ntube = @beanstalk.tubes[\"some-tube-here\"]\r\ntube.clear # tube will now be empty\r\n```\r\n\r\nIn summary, each beanstalk client manages two separate concerns: which tube newly created jobs are put into, \r\nand which tube(s) jobs are reserved from. Accordingly, there are two separate sets of functions for these concerns:\r\n\r\n  * **use** and **using** affect where 'put' places jobs\r\n  * **watch** and **watching** control where reserve takes jobs from\r\n\r\nNote that these concerns are fully orthogonal: for example, when you 'use' a tube, it is not automatically 'watched'. \r\nNeither does 'watching' a tube affect the tube you are 'using'.\r\n\r\n### Jobs\r\n\r\nA job in beanstalk gets inserted by a client and includes the 'body' and job metadata.\r\nEach job is enqueued into a tube and later reserved and processed. Here is a picture of the typical job lifecycle:\r\n\r\n```\r\n   put            reserve               delete\r\n  -----> [READY] ---------> [RESERVED] --------> *poof*\r\n```\r\n\r\nA job at any given time is in one of three states: **ready**, **delayed**, or **buried**:\r\n\r\n * A **ready** job is waiting to be 'reserved' and processed after being 'put' onto a tube.\r\n * A **delayed** job is waiting to become ready after the specified delay.\r\n * A **buried** job has been reserved and buried, will not be reprocessed and is isolated for later use.\r\n\r\nIn addition, there are several actions that can be performed on a given job:\r\n \r\n * You can **reserve** which locks a job from the ready queue for processing.\r\n * You can **touch** which extends the time before a job is autoreleased back to ready.\r\n * You can **release** which places a reserved job back onto the ready queue.\r\n * You can **delete** which removes a job from beanstalk. \r\n * You can **bury** which places a reserved job into the buried state.\r\n * You can **kick** which places a buried job from the buried queue back to ready.\r\n\r\nYou can insert a job onto a beanstalk tube using the `put` command:\r\n\r\n```ruby\r\n@tube.put \"job-data-here\"\r\n```\r\n\r\nEach job has various metadata associated such as `priority`, `delay`, and `ttr` which can be \r\nspecified as part of the `put` command:\r\n\r\n```ruby\r\n# defaults are priority 0, delay of 0 and ttr of 120 seconds\r\n@tube.put \"job-data-here\", :pri => 1000, :delay => 50, :ttr => 200\r\n```\r\n\r\nThe `priority` argument is an integer < 2**32. Jobs with a smaller priority take precedence over jobs with larger priorities. \r\nThe `delay` argument is an integer number of seconds to wait before putting the job in the ready queue.\r\nThe `ttr` argument is the time to run -- is an integer number of seconds to allow a worker to run this job. \r\n\r\n### Processing Jobs (Manually)\r\n\r\nIn order to process jobs, the client should first specify the intended tubes to be watched. If not specified, \r\nthis will default to watching just the `default` tube. \r\n\r\n```ruby\r\n@beanstalk = Beaneater::Connection.new(['10.0.1.5:11300'])\r\n@beanstalk.tubes.watch!('tube-name', 'other-tube')\r\n```\r\n\r\nNext you can use the `reserve` command which will return the first available job within the watched tubes:\r\n\r\n```ruby\r\njob = @beanstalk.tubes.reserve\r\n# => <Beaneater::Job id=5 body=\"foo\">\r\nputs job.body\r\n# prints 'job-data-here'\r\nprint job.stats.state # => 'reserved'\r\n```\r\n\r\nBy default, reserve will wait indefinitely for the next job. If you want to specify a timeout,\r\nsimply pass that in seconds into the command:\r\n\r\n```ruby\r\njob = @beanstalk.tubes.reserve(5) # wait 5 secs for a job, then return\r\n# => <Beaneater::Job id=5 body=\"foo\">\r\n```\r\n\r\nYou can 'release' a reserved job back onto the ready queue to retry later:\r\n\r\n```ruby\r\njob = @beanstalk.tubes.reserve\r\n# ...job has ephemeral fail...\r\njob.release :delay => 5\r\nprint job.stats.state # => 'delayed'\r\n```\r\n\r\nYou can also 'delete' jobs that are finished:\r\n\r\n```ruby\r\njob = @beanstalk.tubes.reserve\r\njob.touch # extends ttr for job\r\n# ...process job...\r\njob.delete\r\n```\r\n\r\nBeanstalk jobs can also be buried if they fail, rather than being deleted:\r\n\r\n```ruby\r\njob = @beanstalk.tubes.reserve\r\n# ...job fails...\r\njob.bury\r\nprint job.stats.state # => 'buried'\r\n```\r\n\r\nBurying a job means that the job is pulled out of the queue into a special 'holding' area for later inspection or reuse.\r\nTo reanimate this job later, you can 'kick' buried jobs back into being ready:\r\n\r\n```ruby\r\n@beanstalk.tubes['some-tube'].kick(3)\r\n```\r\n\r\nThis kicks 3 buried jobs for 'some-tube' back into the 'ready' state. Jobs can also be\r\ninspected using the 'peek' commands. To find and peek at a particular job based on the id:\r\n\r\n```ruby\r\n@beanstalk.jobs.find(123)\r\n# => <Beaneater::Job id=123 body=\"foo\">\r\n```\r\n\r\nor you can peek at jobs within a tube:\r\n\r\n```ruby\r\n@tube = @beanstalk.tubes.find('foo')\r\n@tube.peek(:ready)\r\n# => <Beaneater::Job id=123 body=\"ready\">\r\n@tube.peek(:buried)\r\n# => <Beaneater::Job id=456 body=\"buried\">\r\n@tube.peek(:delayed)\r\n# => <Beaneater::Job id=789 body=\"delayed\">\r\n```\r\n\r\nWhen dealing with jobs there are a few other useful commands available:\r\n\r\n```ruby\r\njob = @beanstalk.tubes.reserve\r\nprint job.tube      # => \"some-tube-name\"\r\nprint job.reserved? # => true\r\nprint job.exists?   # => true\r\njob.delete\r\nprint job.exists?   # => false\r\n```\r\n\r\n### Processing Jobs (Automatically)\r\n\r\nInstead of using `watch` and `reserve`, you can also use the higher level `register` and `process` methods to\r\nprocess jobs. First you can 'register' how to handle jobs from various tubes:\r\n\r\n```ruby\r\n@beanstalk.jobs.register('some-tube-name', :retry_on => [SomeCustomException]) do |job|\r\n  do_something(job)\r\nend\r\n\r\n@beanstalk.jobs.register('some-other-name') do |job|\r\n  do_something_else(job)\r\nend\r\n```\r\n\r\nOnce you have registered the handlers for known tubes, calling `process!` will begin a\r\nloop processing jobs as defined by the registered processor blocks:\r\n\r\n```ruby\r\n@beanstalk.jobs.process!\r\n```\r\n\r\nProcessing runs the following steps:\r\n \r\n 1. Watch all registered tubes\r\n 1. Reserve the next job\r\n 1. Once job is reserved, invoke the registered handler based on the tube name\r\n 1. If no exceptions occur, delete the job (success)\r\n 1. If 'retry_on' exceptions occur, call 'release' (retry)\r\n 1. If other exception occurs, call 'bury' (error)\r\n 1. Repeat steps 2-5\r\n\r\nThe `process` command is ideally suited for a beanstalk job processing daemon.\r\n\r\n### Handling Errors\r\n\r\nWhile using Beaneater, certain errors may be encountered. Errors are encountered when\r\na command is sent to beanstalk and something unexpected happens. The most common errors\r\nare listed below:\r\n\r\n| Errors                      | Description   |\r\n| --------------------        | ------------- |\r\n| Beaneater::NotConnected     | Client connection to beanstalk cannot be established. |\r\n| Beaneater::InvalidTubeName  | Specified tube name for use or watch is not valid.    |\r\n| Beaneater::NotFoundError    | Specified job or tube could not be found.             |\r\n| Beaneater::TimedOutError    | Job could not be reserved within time specified.      |\r\n\r\nThere are other exceptions that are less common such as `OutOfMemoryError`, `DrainingError`,\r\n`DeadlineSoonError`, `InternalError`, `BadFormatError`, `UnknownCommandError`,\r\n`ExpectedCRLFError`, `JobTooBigError`, `NotIgnoredError`. Be sure to check the \r\n[beanstalk protocol](https://github.com/kr/beanstalkd/blob/master/doc/protocol.md) for more information.\r\n\r\n\r\n### Stats\r\n\r\nBeanstalk has plenty of commands for introspecting the state of the queues and jobs. To get stats for\r\nbeanstalk overall:\r\n\r\n```ruby\r\n# Get overall stats about the job processing that has occurred\r\nprint @beanstalk.stats\r\n# => { 'current_connections': 1, 'current_jobs_buried': 0, 'current_jobs_delayed': 0, ... }\r\nprint @beanstalk.stats.current_connections\r\n# => 1\r\n```\r\n\r\nFor stats on a particular tube:\r\n\r\n```ruby\r\n# Get statistical information about the specified tube if it exists\r\nprint @beanstalk.tubes['some_tube_name'].stats\r\n# => { 'current_jobs_ready': 0, 'current_jobs_reserved': 0, 'current_jobs_buried': 0, ...  }\r\n```\r\n\r\nFor stats on an individual job:\r\n\r\n```ruby\r\n# Get statistical information about the specified job if it exists\r\nprint @beanstalk.jobs[some_job_id].stats\r\n# => {'age': 0, 'id': 2, 'state': 'reserved', 'tube': 'default', ... }\r\n```\r\n\r\nBe sure to check the [beanstalk protocol](https://github.com/kr/beanstalkd/blob/master/doc/protocol.md) for\r\nmore details about the stats commands.\r\n\r\n## Resources\r\n\r\nThere are other resources helpful when learning about beanstalk:\r\n\r\n * [Beanstalkd homepage](http://kr.github.com/beanstalkd/)\r\n * [beanstalk on github](https://github.com/kr/beanstalkd)\r\n * [beanstalk protocol](https://github.com/kr/beanstalkd/blob/master/doc/protocol.md)\r\n\r\n## Contributors\r\n\r\n - [Nico Taing](https://github.com/Nico-Taing) - Creator and co-maintainer\r\n - [Nathan Esquenazi](https://github.com/nesquena) - Contributor and co-maintainer"}